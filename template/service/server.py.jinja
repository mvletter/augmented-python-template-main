"""
!!! DISCLAIMER !!! DO NOT EDIT THIS FILE.
"""

import json
import logging
import logging.config
import time
import uuid
from typing import Any

import sentry_sdk
from asgi_logger.middleware import AccessLoggerMiddleware
from fastapi import FastAPI
from fastapi.exceptions import RequestValidationError
from fastapi.middleware import Middleware
from fastapi.openapi.utils import get_openapi
from opentelemetry import trace
from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter
from opentelemetry.instrumentation.aiohttp_client import AioHttpClientInstrumentor
from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor
from opentelemetry.instrumentation.logging import LoggingInstrumentor
from opentelemetry.sdk.resources import SERVICE_NAME, Resource
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import ConsoleSpanExporter
from segment import analytics
from sentry_sdk.integrations.aiohttp import AioHttpIntegration
{% if include_redis %}
from sentry_sdk.integrations.redis import RedisIntegration
{% endif %}
{% if include_database %}
from sentry_sdk.integrations.sqlalchemy import SqlalchemyIntegration
{% endif %}
from sentry_sdk.types import Event, Hint
from starlette_prometheus import PrometheusMiddleware

from holo.adapters.http.exceptions import HTTPException
from holo.adapters.http.openapi import default_response
from holo.adapters.http.utils import (
    standardized_http_exception_handler,
    unknown_exception_handler,
    validation_exception_handler,
)
from holo.config import config
{% if include_database or include_redis %}
from holo.core.exceptions import is_database_shutting_down_error
{% endif %}
from holo.ctx import ASGIContextMiddleware
from holo.opentelemetry.processors import PeerSpanProcessor
from holo.segment.middleware import SegmentASGIMiddleware
from service.lifespan import Lifespan
{% if include_database %}
from service.monitoring.endpoints import debug_sql, health, metrics, ping
from service.monitoring.middleware import SqlMonitorMiddleware
{% else %}
from service.monitoring.endpoints import health, metrics, ping
{% endif %}
from service.router import main_router
{% if include_database %}


try:
    from service.monitoring.sql import SqlMonitor
except ImportError:
    SqlMonitor = None
{% endif %}


#######################
# START SETUP LOGGING #
#######################
logging.config.dictConfig(config.logging.DICT_CONFIG)
# Ensure ALL loglines use GMT/UTC as timezone.
logging.Formatter.converter = time.gmtime
#####################
# END SETUP LOGGING #
#####################

logger = logging.getLogger(__name__)


# Add error reporting.
if config.service.SENTRY_DSN and not config.service.TESTING:
    sentry_config: dict[str, Any] = {"dsn": config.service.SENTRY_DSN}
    if config.service.ENVIRONMENT:
        sentry_config["environment"] = config.service.ENVIRONMENT
    if config.service.APP_IMAGE_TAG:
        sentry_config["release"] = config.service.APP_IMAGE_TAG
    sentry_config["integrations"] = [
        AioHttpIntegration(),
        {% if include_redis %}
        RedisIntegration(),
        {% endif %}
        {% if include_database %}
        SqlalchemyIntegration(),
        {% endif %}
    ]

    def before_send(event: Event, hint: Hint) -> Event | None:
        """
        Will redact all configured variables in stackframes.
        {% if include_database or include_redis %}

        Also ignores errors that require no action, for example errors from
        asyncpg warning about a database leader handover.
        {% endif %}
        """
        {% if include_database or include_redis %}
        exception_type, exception, trace = hint.get("exc_info", [None, None, None])
        if is_database_shutting_down_error(exception, exception_type=exception_type, trace=trace):
            return None

        {% endif %}
        if redacted_vars := config.service.SENTRY_REDACTED_VARIABLES:
            for value in event["exception"]["values"]:
                for frame in value["stacktrace"]["frames"]:
                    frame_vars = frame["vars"]
                    intersecting_keys = redacted_vars.intersection(frame_vars)
                    frame_vars.update((v, "REDACTED") for v in intersecting_keys)

        return event

    sentry_config["before_send"] = before_send
    sentry_sdk.init(**sentry_config)

app = FastAPI(
    lifespan=Lifespan()(),
    responses=default_response,
    middleware=[
        Middleware(
            AccessLoggerMiddleware,
            format='%(h)s %(l)s "%(R)s" %(s)s "%(a)s"',
            logger=logging.getLogger("access"),
        ),
    ],
)

# Add tracing.
if config.service.TRACING and not config.service.TESTING:
    resource = Resource(
        attributes={
            SERVICE_NAME: "{{ service_name }}",
            "environment": config.service.ENVIRONMENT,
        },
    )

    provider = TracerProvider(resource=resource)
    if config.service.REMOTE_TRACING:
        exporter = OTLPSpanExporter(endpoint=config.service.OTLP_ENDPOINT)
    else:
        exporter = ConsoleSpanExporter()
    processor = PeerSpanProcessor(exporter)
    provider.add_span_processor(processor)
    trace.set_tracer_provider(provider)

    LoggingInstrumentor().instrument(set_logging_format=True)

    FastAPIInstrumentor.instrument_app(app, excluded_urls="health,ping,metrics", tracer_provider=provider)
    AioHttpClientInstrumentor().instrument()

# Add middlewares.
if config.segment.SEGMENT_WRITE_KEY or config.service.TESTING:
    analytics.write_key = config.segment.SEGMENT_WRITE_KEY
    analytics.send = not config.service.TESTING
    app.add_middleware(SegmentASGIMiddleware)

app.add_middleware(ASGIContextMiddleware)
app.add_middleware(PrometheusMiddleware)
{% if include_database %}
if SqlMonitor and "request" in config.database.SQL_MONITOR:
    app.add_middleware(SqlMonitorMiddleware)
{% endif %}

# Add exception handlers.
# NOTE: We could also catch all validation errors that come from the core but adding
# another handler for the pydantic ValidationError. We might want to do that in the future.
app.add_exception_handler(RequestValidationError, validation_exception_handler)
app.add_exception_handler(HTTPException, standardized_http_exception_handler)
app.add_exception_handler(Exception, unknown_exception_handler)

# Add internal platform related routes.
app.add_api_route("/ping", ping, methods=["GET"], include_in_schema=False)
app.add_api_route("/health", health, methods=["GET"], include_in_schema=False)
app.add_api_route("/metrics", metrics, methods=["GET"], include_in_schema=False)
{% if include_database %}
if SqlMonitor and "summary" in config.database.SQL_MONITOR:
    app.add_api_route("/debug/sql", debug_sql, methods=["GET"], include_in_schema=False)
{% endif %}

if config.service.HTTP_ENABLED:
    # Add the main router for all assets.
    app.include_router(main_router)


# Customize the openapi spec that is generated.
def custom_openapi() -> dict[str, Any]:
    """
    Custom renderer for the openapi spec on the /docs endpoint.
    """
    if not app.openapi_schema:
        openapi_schema = get_openapi(
            title=config.openapi.TITLE,
            version=config.openapi.VERSION,
            description=config.openapi.DESCRIPTION,
            routes=app.routes,
            contact={
                "email": config.openapi.CONTACT_EMAIL,
                "name": config.openapi.CONTACT_NAME,
                "url": config.openapi.CONTRACT_URL,
            },
            servers=config.openapi.SERVERS,
            tags=config.openapi.TAGS,
        )
        openapi_schema["info"]["x-audience"] = config.openapi.AUDIENCE
        openapi_schema["info"]["x-api-id"] = str(
            uuid.uuid5(uuid.NAMESPACE_DNS, json.dumps(openapi_schema, sort_keys=True)),
        )
        app.openapi_schema = openapi_schema
    return app.openapi_schema


app.openapi = custom_openapi
